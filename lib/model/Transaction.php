<?php
/**
 * Transaction
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Gr4vy
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Gr4vy API
 *
 * Welcome to the Gr4vy API reference documentation. Our API is still very much a work in product and subject to change.
 *
 * The version of the OpenAPI document: 1.1.0-beta
 * Contact: code@gr4vy.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Gr4vy\model;

use \ArrayAccess;
use \Gr4vy\ObjectSerializer;

/**
 * Transaction Class Doc Comment
 *
 * @category Class
 * @description A transaction record.
 * @package  Gr4vy
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class Transaction implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Transaction';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'type' => 'string',
        'id' => 'string',
        'status' => 'string',
        'intent' => 'string',
        'amount' => 'int',
        'captured_amount' => 'int',
        'refunded_amount' => 'int',
        'currency' => 'string',
        'country' => 'string',
        'payment_method' => '\Gr4vy\model\TransactionPaymentMethod',
        'buyer' => '\Gr4vy\model\TransactionBuyer',
        'created_at' => '\DateTime',
        'external_identifier' => 'string',
        'updated_at' => '\DateTime',
        'payment_service' => '\Gr4vy\model\PaymentMethodTokenPaymentService',
        'merchant_initiated' => 'bool',
        'payment_source' => 'string',
        'is_subsequent_payment' => 'bool',
        'statement_descriptor' => '\Gr4vy\model\TransactionStatementDescriptor',
        'cart_items' => '\Gr4vy\model\CartItem[]',
        'scheme_transaction_id' => 'string',
        'raw_response_code' => 'string',
        'raw_response_description' => 'string',
        'avs_response_code' => 'string',
        'cvv_response_code' => 'string',
        'method' => 'string',
        'payment_service_transaction_id' => 'string',
        'metadata' => 'array<string,string>',
        'three_d_secure' => '\Gr4vy\model\ThreeDSecureSummary',
        'authorized_at' => '\DateTime',
        'captured_at' => '\DateTime',
        'voided_at' => '\DateTime'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'type' => null,
        'id' => 'uuid',
        'status' => null,
        'intent' => null,
        'amount' => null,
        'captured_amount' => null,
        'refunded_amount' => null,
        'currency' => null,
        'country' => null,
        'payment_method' => null,
        'buyer' => null,
        'created_at' => 'date-time',
        'external_identifier' => null,
        'updated_at' => 'date-time',
        'payment_service' => null,
        'merchant_initiated' => null,
        'payment_source' => null,
        'is_subsequent_payment' => null,
        'statement_descriptor' => null,
        'cart_items' => null,
        'scheme_transaction_id' => null,
        'raw_response_code' => null,
        'raw_response_description' => null,
        'avs_response_code' => null,
        'cvv_response_code' => null,
        'method' => null,
        'payment_service_transaction_id' => null,
        'metadata' => null,
        'three_d_secure' => null,
        'authorized_at' => 'date-time',
        'captured_at' => 'date-time',
        'voided_at' => 'date-time'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'id' => 'id',
        'status' => 'status',
        'intent' => 'intent',
        'amount' => 'amount',
        'captured_amount' => 'captured_amount',
        'refunded_amount' => 'refunded_amount',
        'currency' => 'currency',
        'country' => 'country',
        'payment_method' => 'payment_method',
        'buyer' => 'buyer',
        'created_at' => 'created_at',
        'external_identifier' => 'external_identifier',
        'updated_at' => 'updated_at',
        'payment_service' => 'payment_service',
        'merchant_initiated' => 'merchant_initiated',
        'payment_source' => 'payment_source',
        'is_subsequent_payment' => 'is_subsequent_payment',
        'statement_descriptor' => 'statement_descriptor',
        'cart_items' => 'cart_items',
        'scheme_transaction_id' => 'scheme_transaction_id',
        'raw_response_code' => 'raw_response_code',
        'raw_response_description' => 'raw_response_description',
        'avs_response_code' => 'avs_response_code',
        'cvv_response_code' => 'cvv_response_code',
        'method' => 'method',
        'payment_service_transaction_id' => 'payment_service_transaction_id',
        'metadata' => 'metadata',
        'three_d_secure' => 'three_d_secure',
        'authorized_at' => 'authorized_at',
        'captured_at' => 'captured_at',
        'voided_at' => 'voided_at'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'id' => 'setId',
        'status' => 'setStatus',
        'intent' => 'setIntent',
        'amount' => 'setAmount',
        'captured_amount' => 'setCapturedAmount',
        'refunded_amount' => 'setRefundedAmount',
        'currency' => 'setCurrency',
        'country' => 'setCountry',
        'payment_method' => 'setPaymentMethod',
        'buyer' => 'setBuyer',
        'created_at' => 'setCreatedAt',
        'external_identifier' => 'setExternalIdentifier',
        'updated_at' => 'setUpdatedAt',
        'payment_service' => 'setPaymentService',
        'merchant_initiated' => 'setMerchantInitiated',
        'payment_source' => 'setPaymentSource',
        'is_subsequent_payment' => 'setIsSubsequentPayment',
        'statement_descriptor' => 'setStatementDescriptor',
        'cart_items' => 'setCartItems',
        'scheme_transaction_id' => 'setSchemeTransactionId',
        'raw_response_code' => 'setRawResponseCode',
        'raw_response_description' => 'setRawResponseDescription',
        'avs_response_code' => 'setAvsResponseCode',
        'cvv_response_code' => 'setCvvResponseCode',
        'method' => 'setMethod',
        'payment_service_transaction_id' => 'setPaymentServiceTransactionId',
        'metadata' => 'setMetadata',
        'three_d_secure' => 'setThreeDSecure',
        'authorized_at' => 'setAuthorizedAt',
        'captured_at' => 'setCapturedAt',
        'voided_at' => 'setVoidedAt'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'id' => 'getId',
        'status' => 'getStatus',
        'intent' => 'getIntent',
        'amount' => 'getAmount',
        'captured_amount' => 'getCapturedAmount',
        'refunded_amount' => 'getRefundedAmount',
        'currency' => 'getCurrency',
        'country' => 'getCountry',
        'payment_method' => 'getPaymentMethod',
        'buyer' => 'getBuyer',
        'created_at' => 'getCreatedAt',
        'external_identifier' => 'getExternalIdentifier',
        'updated_at' => 'getUpdatedAt',
        'payment_service' => 'getPaymentService',
        'merchant_initiated' => 'getMerchantInitiated',
        'payment_source' => 'getPaymentSource',
        'is_subsequent_payment' => 'getIsSubsequentPayment',
        'statement_descriptor' => 'getStatementDescriptor',
        'cart_items' => 'getCartItems',
        'scheme_transaction_id' => 'getSchemeTransactionId',
        'raw_response_code' => 'getRawResponseCode',
        'raw_response_description' => 'getRawResponseDescription',
        'avs_response_code' => 'getAvsResponseCode',
        'cvv_response_code' => 'getCvvResponseCode',
        'method' => 'getMethod',
        'payment_service_transaction_id' => 'getPaymentServiceTransactionId',
        'metadata' => 'getMetadata',
        'three_d_secure' => 'getThreeDSecure',
        'authorized_at' => 'getAuthorizedAt',
        'captured_at' => 'getCapturedAt',
        'voided_at' => 'getVoidedAt'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_TRANSACTION = 'transaction';
    public const STATUS_PROCESSING = 'processing';
    public const STATUS_BUYER_APPROVAL_PENDING = 'buyer_approval_pending';
    public const STATUS_AUTHORIZATION_SUCCEEDED = 'authorization_succeeded';
    public const STATUS_AUTHORIZATION_FAILED = 'authorization_failed';
    public const STATUS_AUTHORIZATION_DECLINED = 'authorization_declined';
    public const STATUS_CAPTURE_PENDING = 'capture_pending';
    public const STATUS_CAPTURE_SUCCEEDED = 'capture_succeeded';
    public const STATUS_AUTHORIZATION_VOID_PENDING = 'authorization_void_pending';
    public const STATUS_AUTHORIZATION_VOIDED = 'authorization_voided';
    public const INTENT_AUTHORIZE = 'authorize';
    public const INTENT_CAPTURE = 'capture';
    public const PAYMENT_SOURCE_ECOMMERCE = 'ecommerce';
    public const PAYMENT_SOURCE_MOTO = 'moto';
    public const PAYMENT_SOURCE_RECURRING = 'recurring';
    public const PAYMENT_SOURCE_INSTALLMENT = 'installment';
    public const PAYMENT_SOURCE_CARD_ON_FILE = 'card_on_file';
    public const AVS_RESPONSE_CODE_NO_MATCH = 'no_match';
    public const AVS_RESPONSE_CODE_MATCH = 'match';
    public const AVS_RESPONSE_CODE_PARTIAL_MATCH_ADDRESS = 'partial_match_address';
    public const AVS_RESPONSE_CODE_PARTIAL_MATCH_POSTCODE = 'partial_match_postcode';
    public const AVS_RESPONSE_CODE_UNAVAILABLE = 'unavailable';
    public const CVV_RESPONSE_CODE_NO_MATCH = 'no_match';
    public const CVV_RESPONSE_CODE_MATCH = 'match';
    public const CVV_RESPONSE_CODE_UNAVAILABLE = 'unavailable';
    public const CVV_RESPONSE_CODE_NOT_PROVIDED = 'not_provided';
    public const METHOD_AFTERPAY = 'afterpay';
    public const METHOD_APPLEPAY = 'applepay';
    public const METHOD_BANKED = 'banked';
    public const METHOD_BITPAY = 'bitpay';
    public const METHOD_BOLETO = 'boleto';
    public const METHOD_CARD = 'card';
    public const METHOD_CLEARPAY = 'clearpay';
    public const METHOD_DANA = 'dana';
    public const METHOD_FORTUMO = 'fortumo';
    public const METHOD_GCASH = 'gcash';
    public const METHOD_GOCARDLESS = 'gocardless';
    public const METHOD_GOOGLEPAY = 'googlepay';
    public const METHOD_GOOGLEPAY_PAN_ONLY = 'googlepay_pan_only';
    public const METHOD_GRABPAY = 'grabpay';
    public const METHOD_KLARNA = 'klarna';
    public const METHOD_OVO = 'ovo';
    public const METHOD_PAYMAYA = 'paymaya';
    public const METHOD_PAYPAL = 'paypal';
    public const METHOD_PIX = 'pix';
    public const METHOD_RABBITLINEPAY = 'rabbitlinepay';
    public const METHOD_SHOPEEPAY = 'shopeepay';
    public const METHOD_STRIPEDD = 'stripedd';
    public const METHOD_TRUEMONEY = 'truemoney';
    public const METHOD_TRUSTLY = 'trustly';
    public const METHOD_ZIPPAY = 'zippay';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_TRANSACTION,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_PROCESSING,
            self::STATUS_BUYER_APPROVAL_PENDING,
            self::STATUS_AUTHORIZATION_SUCCEEDED,
            self::STATUS_AUTHORIZATION_FAILED,
            self::STATUS_AUTHORIZATION_DECLINED,
            self::STATUS_CAPTURE_PENDING,
            self::STATUS_CAPTURE_SUCCEEDED,
            self::STATUS_AUTHORIZATION_VOID_PENDING,
            self::STATUS_AUTHORIZATION_VOIDED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getIntentAllowableValues()
    {
        return [
            self::INTENT_AUTHORIZE,
            self::INTENT_CAPTURE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPaymentSourceAllowableValues()
    {
        return [
            self::PAYMENT_SOURCE_ECOMMERCE,
            self::PAYMENT_SOURCE_MOTO,
            self::PAYMENT_SOURCE_RECURRING,
            self::PAYMENT_SOURCE_INSTALLMENT,
            self::PAYMENT_SOURCE_CARD_ON_FILE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAvsResponseCodeAllowableValues()
    {
        return [
            self::AVS_RESPONSE_CODE_NO_MATCH,
            self::AVS_RESPONSE_CODE_MATCH,
            self::AVS_RESPONSE_CODE_PARTIAL_MATCH_ADDRESS,
            self::AVS_RESPONSE_CODE_PARTIAL_MATCH_POSTCODE,
            self::AVS_RESPONSE_CODE_UNAVAILABLE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCvvResponseCodeAllowableValues()
    {
        return [
            self::CVV_RESPONSE_CODE_NO_MATCH,
            self::CVV_RESPONSE_CODE_MATCH,
            self::CVV_RESPONSE_CODE_UNAVAILABLE,
            self::CVV_RESPONSE_CODE_NOT_PROVIDED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMethodAllowableValues()
    {
        return [
            self::METHOD_AFTERPAY,
            self::METHOD_APPLEPAY,
            self::METHOD_BANKED,
            self::METHOD_BITPAY,
            self::METHOD_BOLETO,
            self::METHOD_CARD,
            self::METHOD_CLEARPAY,
            self::METHOD_DANA,
            self::METHOD_FORTUMO,
            self::METHOD_GCASH,
            self::METHOD_GOCARDLESS,
            self::METHOD_GOOGLEPAY,
            self::METHOD_GOOGLEPAY_PAN_ONLY,
            self::METHOD_GRABPAY,
            self::METHOD_KLARNA,
            self::METHOD_OVO,
            self::METHOD_PAYMAYA,
            self::METHOD_PAYPAL,
            self::METHOD_PIX,
            self::METHOD_RABBITLINEPAY,
            self::METHOD_SHOPEEPAY,
            self::METHOD_STRIPEDD,
            self::METHOD_TRUEMONEY,
            self::METHOD_TRUSTLY,
            self::METHOD_ZIPPAY,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['type'] = $data['type'] ?? null;
        $this->container['id'] = $data['id'] ?? null;
        $this->container['status'] = $data['status'] ?? null;
        $this->container['intent'] = $data['intent'] ?? null;
        $this->container['amount'] = $data['amount'] ?? null;
        $this->container['captured_amount'] = $data['captured_amount'] ?? null;
        $this->container['refunded_amount'] = $data['refunded_amount'] ?? null;
        $this->container['currency'] = $data['currency'] ?? null;
        $this->container['country'] = $data['country'] ?? null;
        $this->container['payment_method'] = $data['payment_method'] ?? null;
        $this->container['buyer'] = $data['buyer'] ?? null;
        $this->container['created_at'] = $data['created_at'] ?? null;
        $this->container['external_identifier'] = $data['external_identifier'] ?? null;
        $this->container['updated_at'] = $data['updated_at'] ?? null;
        $this->container['payment_service'] = $data['payment_service'] ?? null;
        $this->container['merchant_initiated'] = $data['merchant_initiated'] ?? false;
        $this->container['payment_source'] = $data['payment_source'] ?? null;
        $this->container['is_subsequent_payment'] = $data['is_subsequent_payment'] ?? false;
        $this->container['statement_descriptor'] = $data['statement_descriptor'] ?? null;
        $this->container['cart_items'] = $data['cart_items'] ?? null;
        $this->container['scheme_transaction_id'] = $data['scheme_transaction_id'] ?? null;
        $this->container['raw_response_code'] = $data['raw_response_code'] ?? null;
        $this->container['raw_response_description'] = $data['raw_response_description'] ?? null;
        $this->container['avs_response_code'] = $data['avs_response_code'] ?? null;
        $this->container['cvv_response_code'] = $data['cvv_response_code'] ?? null;
        $this->container['method'] = $data['method'] ?? null;
        $this->container['payment_service_transaction_id'] = $data['payment_service_transaction_id'] ?? null;
        $this->container['metadata'] = $data['metadata'] ?? null;
        $this->container['three_d_secure'] = $data['three_d_secure'] ?? null;
        $this->container['authorized_at'] = $data['authorized_at'] ?? null;
        $this->container['captured_at'] = $data['captured_at'] ?? null;
        $this->container['voided_at'] = $data['voided_at'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getIntentAllowableValues();
        if (!is_null($this->container['intent']) && !in_array($this->container['intent'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'intent', must be one of '%s'",
                $this->container['intent'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['amount']) && ($this->container['amount'] > 99999999)) {
            $invalidProperties[] = "invalid value for 'amount', must be smaller than or equal to 99999999.";
        }

        if (!is_null($this->container['amount']) && ($this->container['amount'] < 0)) {
            $invalidProperties[] = "invalid value for 'amount', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['captured_amount']) && ($this->container['captured_amount'] > 99999999)) {
            $invalidProperties[] = "invalid value for 'captured_amount', must be smaller than or equal to 99999999.";
        }

        if (!is_null($this->container['captured_amount']) && ($this->container['captured_amount'] < 0)) {
            $invalidProperties[] = "invalid value for 'captured_amount', must be bigger than or equal to 0.";
        }

        if (!is_null($this->container['refunded_amount']) && ($this->container['refunded_amount'] > 99999999)) {
            $invalidProperties[] = "invalid value for 'refunded_amount', must be smaller than or equal to 99999999.";
        }

        if (!is_null($this->container['refunded_amount']) && ($this->container['refunded_amount'] < 0)) {
            $invalidProperties[] = "invalid value for 'refunded_amount', must be bigger than or equal to 0.";
        }

        $allowedValues = $this->getPaymentSourceAllowableValues();
        if (!is_null($this->container['payment_source']) && !in_array($this->container['payment_source'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'payment_source', must be one of '%s'",
                $this->container['payment_source'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAvsResponseCodeAllowableValues();
        if (!is_null($this->container['avs_response_code']) && !in_array($this->container['avs_response_code'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'avs_response_code', must be one of '%s'",
                $this->container['avs_response_code'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCvvResponseCodeAllowableValues();
        if (!is_null($this->container['cvv_response_code']) && !in_array($this->container['cvv_response_code'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'cvv_response_code', must be one of '%s'",
                $this->container['cvv_response_code'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getMethodAllowableValues();
        if (!is_null($this->container['method']) && !in_array($this->container['method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'method', must be one of '%s'",
                $this->container['method'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type The type of this resource. Is always `transaction`.
     *
     * @return self
     */
    public function setType($type)
    {
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($type) && !in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id The unique identifier for this transaction.
     *
     * @return self
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status The status of the transaction. The status may change over time as asynchronous processing events occur.
     *
     * @return self
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'status', must be one of '%s'",
                    $status,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets intent
     *
     * @return string|null
     */
    public function getIntent()
    {
        return $this->container['intent'];
    }

    /**
     * Sets intent
     *
     * @param string|null $intent The original `intent` used when the transaction was [created](#operation/authorize-new-transaction).
     *
     * @return self
     */
    public function setIntent($intent)
    {
        $allowedValues = $this->getIntentAllowableValues();
        if (!is_null($intent) && !in_array($intent, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'intent', must be one of '%s'",
                    $intent,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['intent'] = $intent;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int|null
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int|null $amount The authorized amount for this transaction. This can be more than the actual captured amount and part of this amount may be refunded.
     *
     * @return self
     */
    public function setAmount($amount)
    {

        if (!is_null($amount) && ($amount > 99999999)) {
            throw new \InvalidArgumentException('invalid value for $amount when calling Transaction., must be smaller than or equal to 99999999.');
        }
        if (!is_null($amount) && ($amount < 0)) {
            throw new \InvalidArgumentException('invalid value for $amount when calling Transaction., must be bigger than or equal to 0.');
        }

        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets captured_amount
     *
     * @return int|null
     */
    public function getCapturedAmount()
    {
        return $this->container['captured_amount'];
    }

    /**
     * Sets captured_amount
     *
     * @param int|null $captured_amount The captured amount for this transaction. This can be the total or a portion of the authorized amount.
     *
     * @return self
     */
    public function setCapturedAmount($captured_amount)
    {

        if (!is_null($captured_amount) && ($captured_amount > 99999999)) {
            throw new \InvalidArgumentException('invalid value for $captured_amount when calling Transaction., must be smaller than or equal to 99999999.');
        }
        if (!is_null($captured_amount) && ($captured_amount < 0)) {
            throw new \InvalidArgumentException('invalid value for $captured_amount when calling Transaction., must be bigger than or equal to 0.');
        }

        $this->container['captured_amount'] = $captured_amount;

        return $this;
    }

    /**
     * Gets refunded_amount
     *
     * @return int|null
     */
    public function getRefundedAmount()
    {
        return $this->container['refunded_amount'];
    }

    /**
     * Sets refunded_amount
     *
     * @param int|null $refunded_amount The refunded amount for this transaction. This can be the total or a portion of the captured amount.
     *
     * @return self
     */
    public function setRefundedAmount($refunded_amount)
    {

        if (!is_null($refunded_amount) && ($refunded_amount > 99999999)) {
            throw new \InvalidArgumentException('invalid value for $refunded_amount when calling Transaction., must be smaller than or equal to 99999999.');
        }
        if (!is_null($refunded_amount) && ($refunded_amount < 0)) {
            throw new \InvalidArgumentException('invalid value for $refunded_amount when calling Transaction., must be bigger than or equal to 0.');
        }

        $this->container['refunded_amount'] = $refunded_amount;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency The currency code for this transaction.
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets country
     *
     * @return string|null
     */
    public function getCountry()
    {
        return $this->container['country'];
    }

    /**
     * Sets country
     *
     * @param string|null $country The 2-letter ISO code of the country of the transaction. This is used to filter the payment services that is used to process the transaction.
     *
     * @return self
     */
    public function setCountry($country)
    {
        $this->container['country'] = $country;

        return $this;
    }

    /**
     * Gets payment_method
     *
     * @return \Gr4vy\model\TransactionPaymentMethod|null
     */
    public function getPaymentMethod()
    {
        return $this->container['payment_method'];
    }

    /**
     * Sets payment_method
     *
     * @param \Gr4vy\model\TransactionPaymentMethod|null $payment_method payment_method
     *
     * @return self
     */
    public function setPaymentMethod($payment_method)
    {
        $this->container['payment_method'] = $payment_method;

        return $this;
    }

    /**
     * Gets buyer
     *
     * @return \Gr4vy\model\TransactionBuyer|null
     */
    public function getBuyer()
    {
        return $this->container['buyer'];
    }

    /**
     * Sets buyer
     *
     * @param \Gr4vy\model\TransactionBuyer|null $buyer buyer
     *
     * @return self
     */
    public function setBuyer($buyer)
    {
        $this->container['buyer'] = $buyer;

        return $this;
    }

    /**
     * Gets created_at
     *
     * @return \DateTime|null
     */
    public function getCreatedAt()
    {
        return $this->container['created_at'];
    }

    /**
     * Sets created_at
     *
     * @param \DateTime|null $created_at The date and time when this transaction was created in our system.
     *
     * @return self
     */
    public function setCreatedAt($created_at)
    {
        $this->container['created_at'] = $created_at;

        return $this;
    }

    /**
     * Gets external_identifier
     *
     * @return string|null
     */
    public function getExternalIdentifier()
    {
        return $this->container['external_identifier'];
    }

    /**
     * Sets external_identifier
     *
     * @param string|null $external_identifier An external identifier that can be used to match the transaction against your own records.
     *
     * @return self
     */
    public function setExternalIdentifier($external_identifier)
    {
        $this->container['external_identifier'] = $external_identifier;

        return $this;
    }

    /**
     * Gets updated_at
     *
     * @return \DateTime|null
     */
    public function getUpdatedAt()
    {
        return $this->container['updated_at'];
    }

    /**
     * Sets updated_at
     *
     * @param \DateTime|null $updated_at Defines when the transaction was last updated.
     *
     * @return self
     */
    public function setUpdatedAt($updated_at)
    {
        $this->container['updated_at'] = $updated_at;

        return $this;
    }

    /**
     * Gets payment_service
     *
     * @return \Gr4vy\model\PaymentMethodTokenPaymentService|null
     */
    public function getPaymentService()
    {
        return $this->container['payment_service'];
    }

    /**
     * Sets payment_service
     *
     * @param \Gr4vy\model\PaymentMethodTokenPaymentService|null $payment_service payment_service
     *
     * @return self
     */
    public function setPaymentService($payment_service)
    {
        $this->container['payment_service'] = $payment_service;

        return $this;
    }

    /**
     * Gets merchant_initiated
     *
     * @return bool|null
     */
    public function getMerchantInitiated()
    {
        return $this->container['merchant_initiated'];
    }

    /**
     * Sets merchant_initiated
     *
     * @param bool|null $merchant_initiated Indicates whether the transaction was initiated by the merchant (true) or customer (false).
     *
     * @return self
     */
    public function setMerchantInitiated($merchant_initiated)
    {
        $this->container['merchant_initiated'] = $merchant_initiated;

        return $this;
    }

    /**
     * Gets payment_source
     *
     * @return string|null
     */
    public function getPaymentSource()
    {
        return $this->container['payment_source'];
    }

    /**
     * Sets payment_source
     *
     * @param string|null $payment_source The source of the transaction. Defaults to `ecommerce`.
     *
     * @return self
     */
    public function setPaymentSource($payment_source)
    {
        $allowedValues = $this->getPaymentSourceAllowableValues();
        if (!is_null($payment_source) && !in_array($payment_source, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'payment_source', must be one of '%s'",
                    $payment_source,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['payment_source'] = $payment_source;

        return $this;
    }

    /**
     * Gets is_subsequent_payment
     *
     * @return bool|null
     */
    public function getIsSubsequentPayment()
    {
        return $this->container['is_subsequent_payment'];
    }

    /**
     * Sets is_subsequent_payment
     *
     * @param bool|null $is_subsequent_payment Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.  The flag can only be `false` (or not set) when the transaction meets one of the following criteria:  * It is not `merchant_initiated`. * `payment_source` is set to `card_on_file`.  The flag can only be set to `true` when the transaction meets one of the following criteria:  * It is not `merchant_initiated`. * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`. * `payment_source` is set to `card_on_file`.
     *
     * @return self
     */
    public function setIsSubsequentPayment($is_subsequent_payment)
    {
        $this->container['is_subsequent_payment'] = $is_subsequent_payment;

        return $this;
    }

    /**
     * Gets statement_descriptor
     *
     * @return \Gr4vy\model\TransactionStatementDescriptor|null
     */
    public function getStatementDescriptor()
    {
        return $this->container['statement_descriptor'];
    }

    /**
     * Sets statement_descriptor
     *
     * @param \Gr4vy\model\TransactionStatementDescriptor|null $statement_descriptor statement_descriptor
     *
     * @return self
     */
    public function setStatementDescriptor($statement_descriptor)
    {
        $this->container['statement_descriptor'] = $statement_descriptor;

        return $this;
    }

    /**
     * Gets cart_items
     *
     * @return \Gr4vy\model\CartItem[]|null
     */
    public function getCartItems()
    {
        return $this->container['cart_items'];
    }

    /**
     * Sets cart_items
     *
     * @param \Gr4vy\model\CartItem[]|null $cart_items An array of cart items that represents the line items of a transaction.
     *
     * @return self
     */
    public function setCartItems($cart_items)
    {


        $this->container['cart_items'] = $cart_items;

        return $this;
    }

    /**
     * Gets scheme_transaction_id
     *
     * @return string|null
     */
    public function getSchemeTransactionId()
    {
        return $this->container['scheme_transaction_id'];
    }

    /**
     * Sets scheme_transaction_id
     *
     * @param string|null $scheme_transaction_id An identifier for the transaction used by the scheme itself, when available.  e.g. the Visa Transaction Identifier, or Mastercard Trace ID.
     *
     * @return self
     */
    public function setSchemeTransactionId($scheme_transaction_id)
    {
        $this->container['scheme_transaction_id'] = $scheme_transaction_id;

        return $this;
    }

    /**
     * Gets raw_response_code
     *
     * @return string|null
     */
    public function getRawResponseCode()
    {
        return $this->container['raw_response_code'];
    }

    /**
     * Sets raw_response_code
     *
     * @param string|null $raw_response_code This is the response code received from the payment service. This can be set to any value and is not standardized across different payment services.
     *
     * @return self
     */
    public function setRawResponseCode($raw_response_code)
    {
        $this->container['raw_response_code'] = $raw_response_code;

        return $this;
    }

    /**
     * Gets raw_response_description
     *
     * @return string|null
     */
    public function getRawResponseDescription()
    {
        return $this->container['raw_response_description'];
    }

    /**
     * Sets raw_response_description
     *
     * @param string|null $raw_response_description This is the response description received from the payment service. This can be set to any value and is not standardized across different payment services.
     *
     * @return self
     */
    public function setRawResponseDescription($raw_response_description)
    {
        $this->container['raw_response_description'] = $raw_response_description;

        return $this;
    }

    /**
     * Gets avs_response_code
     *
     * @return string|null
     */
    public function getAvsResponseCode()
    {
        return $this->container['avs_response_code'];
    }

    /**
     * Sets avs_response_code
     *
     * @param string|null $avs_response_code The response code received from the payment service for the Address Verification Check (AVS). This code is mapped to a standardized Gr4vy AVS response code.  - `no_match` - neither address or postal code match - `match` - both address and postal code match - `partial_match_address` - address matches but postal code does not - `partial_match_postcode` - postal code matches but address does not - `unavailable ` - AVS is unavailable for card/country  The value of this field can be `null` if the payment service did not provide a response.
     *
     * @return self
     */
    public function setAvsResponseCode($avs_response_code)
    {
        $allowedValues = $this->getAvsResponseCodeAllowableValues();
        if (!is_null($avs_response_code) && !in_array($avs_response_code, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'avs_response_code', must be one of '%s'",
                    $avs_response_code,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['avs_response_code'] = $avs_response_code;

        return $this;
    }

    /**
     * Gets cvv_response_code
     *
     * @return string|null
     */
    public function getCvvResponseCode()
    {
        return $this->container['cvv_response_code'];
    }

    /**
     * Sets cvv_response_code
     *
     * @param string|null $cvv_response_code The response code received from the payment service for the Card Verification Value (CVV). This code is mapped to a standardized Gr4vy CVV response code.  - `no_match` - the CVV does not match the expected value - `match` - the CVV matches the expected value - `unavailable ` - CVV check unavailable for card our country - `not_provided ` - CVV not provided  The value of this field can be `null` if the payment service did not provide a response.
     *
     * @return self
     */
    public function setCvvResponseCode($cvv_response_code)
    {
        $allowedValues = $this->getCvvResponseCodeAllowableValues();
        if (!is_null($cvv_response_code) && !in_array($cvv_response_code, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'cvv_response_code', must be one of '%s'",
                    $cvv_response_code,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['cvv_response_code'] = $cvv_response_code;

        return $this;
    }

    /**
     * Gets method
     *
     * @return string|null
     */
    public function getMethod()
    {
        return $this->container['method'];
    }

    /**
     * Sets method
     *
     * @param string|null $method method
     *
     * @return self
     */
    public function setMethod($method)
    {
        $allowedValues = $this->getMethodAllowableValues();
        if (!is_null($method) && !in_array($method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'method', must be one of '%s'",
                    $method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['method'] = $method;

        return $this;
    }

    /**
     * Gets payment_service_transaction_id
     *
     * @return string|null
     */
    public function getPaymentServiceTransactionId()
    {
        return $this->container['payment_service_transaction_id'];
    }

    /**
     * Sets payment_service_transaction_id
     *
     * @param string|null $payment_service_transaction_id The payment service's unique ID for the transaction.
     *
     * @return self
     */
    public function setPaymentServiceTransactionId($payment_service_transaction_id)
    {
        $this->container['payment_service_transaction_id'] = $payment_service_transaction_id;

        return $this;
    }

    /**
     * Gets metadata
     *
     * @return array<string,string>|null
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param array<string,string>|null $metadata Additional information about the transaction stored as key-value pairs.
     *
     * @return self
     */
    public function setMetadata($metadata)
    {
        $this->container['metadata'] = $metadata;

        return $this;
    }

    /**
     * Gets three_d_secure
     *
     * @return \Gr4vy\model\ThreeDSecureSummary|null
     */
    public function getThreeDSecure()
    {
        return $this->container['three_d_secure'];
    }

    /**
     * Sets three_d_secure
     *
     * @param \Gr4vy\model\ThreeDSecureSummary|null $three_d_secure three_d_secure
     *
     * @return self
     */
    public function setThreeDSecure($three_d_secure)
    {
        $this->container['three_d_secure'] = $three_d_secure;

        return $this;
    }

    /**
     * Gets authorized_at
     *
     * @return \DateTime|null
     */
    public function getAuthorizedAt()
    {
        return $this->container['authorized_at'];
    }

    /**
     * Sets authorized_at
     *
     * @param \DateTime|null $authorized_at The date and time when this transaction was authorized in the payment service.  Don't use this field to determine whether the transaction was authorized. A `null` value doesn't necessarily imply that the transaction wasn't authorized, it can mean that the payment service doesn't provide this value, that it didn't provide it at the time the transaction was authorized or that the transaction was authorized before the introduction of this field.
     *
     * @return self
     */
    public function setAuthorizedAt($authorized_at)
    {
        $this->container['authorized_at'] = $authorized_at;

        return $this;
    }

    /**
     * Gets captured_at
     *
     * @return \DateTime|null
     */
    public function getCapturedAt()
    {
        return $this->container['captured_at'];
    }

    /**
     * Sets captured_at
     *
     * @param \DateTime|null $captured_at The date and time when this transaction was captured in the payment service.  Don't use this field to determine whether the transaction was captured. A `null` value doesn't necessarily imply that the transaction wasn't captured, it can mean that the payment service doesn't provide this value, that it didn't provide it at the time the transaction was captured or that the transaction was captured before the introduction of this field.
     *
     * @return self
     */
    public function setCapturedAt($captured_at)
    {
        $this->container['captured_at'] = $captured_at;

        return $this;
    }

    /**
     * Gets voided_at
     *
     * @return \DateTime|null
     */
    public function getVoidedAt()
    {
        return $this->container['voided_at'];
    }

    /**
     * Sets voided_at
     *
     * @param \DateTime|null $voided_at The date and time when this transaction was voided in the payment service.  Don't use this field to determine whether the transaction was voided. A `null` value doesn't necessarily imply that the transaction wasn't voided, it can mean that the payment service doesn't provide this value, that it didn't provide it at the time the transaction was voided or that the transaction was voided before the introduction of this field.
     *
     * @return self
     */
    public function setVoidedAt($voided_at)
    {
        $this->container['voided_at'] = $voided_at;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


