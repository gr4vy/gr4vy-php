<?php
/**
 * TransactionPaymentMethod
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Gr4vy
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Gr4vy API
 *
 * Welcome to the Gr4vy API reference documentation. Our API is still very much a work in product and subject to change.
 *
 * The version of the OpenAPI document: 1.1.0-beta
 * Contact: code@gr4vy.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Gr4vy\model;

use \ArrayAccess;
use \Gr4vy\ObjectSerializer;

/**
 * TransactionPaymentMethod Class Doc Comment
 *
 * @category Class
 * @description The payment method used for this transaction.
 * @package  Gr4vy
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<TKey, TValue>
 * @template TKey int|null
 * @template TValue mixed|null
 */
class TransactionPaymentMethod implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'Transaction_payment_method';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'type' => 'string',
        'id' => 'string',
        'approval_target' => 'string',
        'approval_url' => 'string',
        'country' => 'string',
        'currency' => 'string',
        'details' => '\Gr4vy\model\PaymentMethodDetailsCard',
        'expiration_date' => 'string',
        'external_identifier' => 'string',
        'label' => 'string',
        'last_replaced_at' => '\DateTime',
        'method' => 'string',
        'payment_account_reference' => 'string',
        'scheme' => 'string',
        'fingerprint' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'type' => null,
        'id' => 'uuid',
        'approval_target' => null,
        'approval_url' => null,
        'country' => null,
        'currency' => null,
        'details' => null,
        'expiration_date' => null,
        'external_identifier' => null,
        'label' => null,
        'last_replaced_at' => 'date-time',
        'method' => null,
        'payment_account_reference' => null,
        'scheme' => null,
        'fingerprint' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'id' => 'id',
        'approval_target' => 'approval_target',
        'approval_url' => 'approval_url',
        'country' => 'country',
        'currency' => 'currency',
        'details' => 'details',
        'expiration_date' => 'expiration_date',
        'external_identifier' => 'external_identifier',
        'label' => 'label',
        'last_replaced_at' => 'last_replaced_at',
        'method' => 'method',
        'payment_account_reference' => 'payment_account_reference',
        'scheme' => 'scheme',
        'fingerprint' => 'fingerprint'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'id' => 'setId',
        'approval_target' => 'setApprovalTarget',
        'approval_url' => 'setApprovalUrl',
        'country' => 'setCountry',
        'currency' => 'setCurrency',
        'details' => 'setDetails',
        'expiration_date' => 'setExpirationDate',
        'external_identifier' => 'setExternalIdentifier',
        'label' => 'setLabel',
        'last_replaced_at' => 'setLastReplacedAt',
        'method' => 'setMethod',
        'payment_account_reference' => 'setPaymentAccountReference',
        'scheme' => 'setScheme',
        'fingerprint' => 'setFingerprint'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'id' => 'getId',
        'approval_target' => 'getApprovalTarget',
        'approval_url' => 'getApprovalUrl',
        'country' => 'getCountry',
        'currency' => 'getCurrency',
        'details' => 'getDetails',
        'expiration_date' => 'getExpirationDate',
        'external_identifier' => 'getExternalIdentifier',
        'label' => 'getLabel',
        'last_replaced_at' => 'getLastReplacedAt',
        'method' => 'getMethod',
        'payment_account_reference' => 'getPaymentAccountReference',
        'scheme' => 'getScheme',
        'fingerprint' => 'getFingerprint'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TYPE_PAYMENT_METHOD = 'payment-method';
    public const APPROVAL_TARGET_ANY = 'any';
    public const APPROVAL_TARGET_NEW_WINDOW = 'new_window';
    public const METHOD_AFTERPAY = 'afterpay';
    public const METHOD_ALIPAY = 'alipay';
    public const METHOD_ALIPAYHK = 'alipayhk';
    public const METHOD_APPLEPAY = 'applepay';
    public const METHOD_BACS = 'bacs';
    public const METHOD_BANCONTACT = 'bancontact';
    public const METHOD_BANKED = 'banked';
    public const METHOD_BECS = 'becs';
    public const METHOD_BITPAY = 'bitpay';
    public const METHOD_BOLETO = 'boleto';
    public const METHOD_BOOST = 'boost';
    public const METHOD_CARD = 'card';
    public const METHOD_CHECKOUT_SESSION = 'checkout-session';
    public const METHOD_CLICK_TO_PAY = 'click-to-pay';
    public const METHOD_CLEARPAY = 'clearpay';
    public const METHOD_DANA = 'dana';
    public const METHOD_DCB = 'dcb';
    public const METHOD_EPS = 'eps';
    public const METHOD_FORTUMO = 'fortumo';
    public const METHOD_GCASH = 'gcash';
    public const METHOD_GIROPAY = 'giropay';
    public const METHOD_GOCARDLESS = 'gocardless';
    public const METHOD_GOOGLEPAY = 'googlepay';
    public const METHOD_GOPAY = 'gopay';
    public const METHOD_GRABPAY = 'grabpay';
    public const METHOD_IDEAL = 'ideal';
    public const METHOD_ID = 'id';
    public const METHOD_KAKAOPAY = 'kakaopay';
    public const METHOD_KLARNA = 'klarna';
    public const METHOD_LAYBUY = 'laybuy';
    public const METHOD_LINEPAY = 'linepay';
    public const METHOD_LINKAJA = 'linkaja';
    public const METHOD_MAYBANKQRPAY = 'maybankqrpay';
    public const METHOD_MULTIBANCO = 'multibanco';
    public const METHOD_ONEY_3X = 'oney_3x';
    public const METHOD_ONEY_4X = 'oney_4x';
    public const METHOD_ONEY_6X = 'oney_6x';
    public const METHOD_ONEY_10X = 'oney_10x';
    public const METHOD_ONEY_12X = 'oney_12x';
    public const METHOD_OVO = 'ovo';
    public const METHOD_OXXO = 'oxxo';
    public const METHOD_PAYMAYA = 'paymaya';
    public const METHOD_PAYPAL = 'paypal';
    public const METHOD_PAYPALPAYLATER = 'paypalpaylater';
    public const METHOD_PIX = 'pix';
    public const METHOD_RABBITLINEPAY = 'rabbitlinepay';
    public const METHOD_RAZORPAY = 'razorpay';
    public const METHOD_SCALAPAY = 'scalapay';
    public const METHOD_SEPA = 'sepa';
    public const METHOD_SHOPEEPAY = 'shopeepay';
    public const METHOD_SINGTELDASH = 'singteldash';
    public const METHOD_SOFORT = 'sofort';
    public const METHOD_STRIPEDD = 'stripedd';
    public const METHOD_THAIQR = 'thaiqr';
    public const METHOD_TOUCHNGO = 'touchngo';
    public const METHOD_TRUEMONEY = 'truemoney';
    public const METHOD_TRUSTLY = 'trustly';
    public const METHOD_VENMO = 'venmo';
    public const METHOD_WAAVE = 'waave';
    public const METHOD_WECHAT = 'wechat';
    public const METHOD_ZIPPAY = 'zippay';
    public const SCHEME_ACCEL = 'accel';
    public const SCHEME_AMEX = 'amex';
    public const SCHEME_BANCONTACT = 'bancontact';
    public const SCHEME_CARTE_BANCAIRE = 'carte-bancaire';
    public const SCHEME_CIRRUS = 'cirrus';
    public const SCHEME_CULIANCE = 'culiance';
    public const SCHEME_DANKORT = 'dankort';
    public const SCHEME_DINERS_CLUB = 'diners-club';
    public const SCHEME_DISCOVER = 'discover';
    public const SCHEME_EFTPOS_AUSTRALIA = 'eftpos-australia';
    public const SCHEME_ELO = 'elo';
    public const SCHEME_HIPERCARD = 'hipercard';
    public const SCHEME_JCB = 'jcb';
    public const SCHEME_MAESTRO = 'maestro';
    public const SCHEME_MASTERCARD = 'mastercard';
    public const SCHEME_NYCE = 'nyce';
    public const SCHEME_OTHER = 'other';
    public const SCHEME_PULSE = 'pulse';
    public const SCHEME_RUPAY = 'rupay';
    public const SCHEME_STAR = 'star';
    public const SCHEME_UNIONPAY = 'unionpay';
    public const SCHEME_VISA = 'visa';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_PAYMENT_METHOD,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getApprovalTargetAllowableValues()
    {
        return [
            self::APPROVAL_TARGET_ANY,
            self::APPROVAL_TARGET_NEW_WINDOW,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getMethodAllowableValues()
    {
        return [
            self::METHOD_AFTERPAY,
            self::METHOD_ALIPAY,
            self::METHOD_ALIPAYHK,
            self::METHOD_APPLEPAY,
            self::METHOD_BACS,
            self::METHOD_BANCONTACT,
            self::METHOD_BANKED,
            self::METHOD_BECS,
            self::METHOD_BITPAY,
            self::METHOD_BOLETO,
            self::METHOD_BOOST,
            self::METHOD_CARD,
            self::METHOD_CHECKOUT_SESSION,
            self::METHOD_CLICK_TO_PAY,
            self::METHOD_CLEARPAY,
            self::METHOD_DANA,
            self::METHOD_DCB,
            self::METHOD_EPS,
            self::METHOD_FORTUMO,
            self::METHOD_GCASH,
            self::METHOD_GIROPAY,
            self::METHOD_GOCARDLESS,
            self::METHOD_GOOGLEPAY,
            self::METHOD_GOPAY,
            self::METHOD_GRABPAY,
            self::METHOD_IDEAL,
            self::METHOD_ID,
            self::METHOD_KAKAOPAY,
            self::METHOD_KLARNA,
            self::METHOD_LAYBUY,
            self::METHOD_LINEPAY,
            self::METHOD_LINKAJA,
            self::METHOD_MAYBANKQRPAY,
            self::METHOD_MULTIBANCO,
            self::METHOD_ONEY_3X,
            self::METHOD_ONEY_4X,
            self::METHOD_ONEY_6X,
            self::METHOD_ONEY_10X,
            self::METHOD_ONEY_12X,
            self::METHOD_OVO,
            self::METHOD_OXXO,
            self::METHOD_PAYMAYA,
            self::METHOD_PAYPAL,
            self::METHOD_PAYPALPAYLATER,
            self::METHOD_PIX,
            self::METHOD_RABBITLINEPAY,
            self::METHOD_RAZORPAY,
            self::METHOD_SCALAPAY,
            self::METHOD_SEPA,
            self::METHOD_SHOPEEPAY,
            self::METHOD_SINGTELDASH,
            self::METHOD_SOFORT,
            self::METHOD_STRIPEDD,
            self::METHOD_THAIQR,
            self::METHOD_TOUCHNGO,
            self::METHOD_TRUEMONEY,
            self::METHOD_TRUSTLY,
            self::METHOD_VENMO,
            self::METHOD_WAAVE,
            self::METHOD_WECHAT,
            self::METHOD_ZIPPAY,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSchemeAllowableValues()
    {
        return [
            self::SCHEME_ACCEL,
            self::SCHEME_AMEX,
            self::SCHEME_BANCONTACT,
            self::SCHEME_CARTE_BANCAIRE,
            self::SCHEME_CIRRUS,
            self::SCHEME_CULIANCE,
            self::SCHEME_DANKORT,
            self::SCHEME_DINERS_CLUB,
            self::SCHEME_DISCOVER,
            self::SCHEME_EFTPOS_AUSTRALIA,
            self::SCHEME_ELO,
            self::SCHEME_HIPERCARD,
            self::SCHEME_JCB,
            self::SCHEME_MAESTRO,
            self::SCHEME_MASTERCARD,
            self::SCHEME_NYCE,
            self::SCHEME_OTHER,
            self::SCHEME_PULSE,
            self::SCHEME_RUPAY,
            self::SCHEME_STAR,
            self::SCHEME_UNIONPAY,
            self::SCHEME_VISA,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['type'] = $data['type'] ?? null;
        $this->container['id'] = $data['id'] ?? null;
        $this->container['approval_target'] = $data['approval_target'] ?? null;
        $this->container['approval_url'] = $data['approval_url'] ?? null;
        $this->container['country'] = $data['country'] ?? null;
        $this->container['currency'] = $data['currency'] ?? null;
        $this->container['details'] = $data['details'] ?? null;
        $this->container['expiration_date'] = $data['expiration_date'] ?? null;
        $this->container['external_identifier'] = $data['external_identifier'] ?? null;
        $this->container['label'] = $data['label'] ?? null;
        $this->container['last_replaced_at'] = $data['last_replaced_at'] ?? null;
        $this->container['method'] = $data['method'] ?? null;
        $this->container['payment_account_reference'] = $data['payment_account_reference'] ?? null;
        $this->container['scheme'] = $data['scheme'] ?? null;
        $this->container['fingerprint'] = $data['fingerprint'] ?? null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'type', must be one of '%s'",
                $this->container['type'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getApprovalTargetAllowableValues();
        if (!is_null($this->container['approval_target']) && !in_array($this->container['approval_target'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'approval_target', must be one of '%s'",
                $this->container['approval_target'],
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['expiration_date']) && (mb_strlen($this->container['expiration_date']) > 5)) {
            $invalidProperties[] = "invalid value for 'expiration_date', the character length must be smaller than or equal to 5.";
        }

        if (!is_null($this->container['expiration_date']) && (mb_strlen($this->container['expiration_date']) < 5)) {
            $invalidProperties[] = "invalid value for 'expiration_date', the character length must be bigger than or equal to 5.";
        }

        if (!is_null($this->container['expiration_date']) && !preg_match("/^\\d{2}\/\\d{2}$/", $this->container['expiration_date'])) {
            $invalidProperties[] = "invalid value for 'expiration_date', must be conform to the pattern /^\\d{2}\/\\d{2}$/.";
        }

        $allowedValues = $this->getMethodAllowableValues();
        if (!is_null($this->container['method']) && !in_array($this->container['method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'method', must be one of '%s'",
                $this->container['method'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSchemeAllowableValues();
        if (!is_null($this->container['scheme']) && !in_array($this->container['scheme'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'scheme', must be one of '%s'",
                $this->container['scheme'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type `payment-method`.
     *
     * @return self
     */
    public function setType($type)
    {
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($type) && !in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'type', must be one of '%s'",
                    $type,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string|null $id The unique ID of the payment method.
     *
     * @return self
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets approval_target
     *
     * @return string|null
     */
    public function getApprovalTarget()
    {
        return $this->container['approval_target'];
    }

    /**
     * Sets approval_target
     *
     * @param string|null $approval_target The browser target that an approval URL must be opened in. If `any` or `null`, then there is no specific requirement.
     *
     * @return self
     */
    public function setApprovalTarget($approval_target)
    {
        $allowedValues = $this->getApprovalTargetAllowableValues();
        if (!is_null($approval_target) && !in_array($approval_target, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'approval_target', must be one of '%s'",
                    $approval_target,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['approval_target'] = $approval_target;

        return $this;
    }

    /**
     * Gets approval_url
     *
     * @return string|null
     */
    public function getApprovalUrl()
    {
        return $this->container['approval_url'];
    }

    /**
     * Sets approval_url
     *
     * @param string|null $approval_url The optional URL that the buyer needs to be redirected to to further authorize their payment.
     *
     * @return self
     */
    public function setApprovalUrl($approval_url)
    {
        $this->container['approval_url'] = $approval_url;

        return $this;
    }

    /**
     * Gets country
     *
     * @return string|null
     */
    public function getCountry()
    {
        return $this->container['country'];
    }

    /**
     * Sets country
     *
     * @param string|null $country The 2-letter ISO code of the country this payment method can be used for. If this value is `null` the payment method may be used in multiple countries.
     *
     * @return self
     */
    public function setCountry($country)
    {
        $this->container['country'] = $country;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency The ISO-4217 currency code that this payment method can be used for. If this value is `null` the payment method may be used for multiple currencies.
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets details
     *
     * @return \Gr4vy\model\PaymentMethodDetailsCard|null
     */
    public function getDetails()
    {
        return $this->container['details'];
    }

    /**
     * Sets details
     *
     * @param \Gr4vy\model\PaymentMethodDetailsCard|null $details details
     *
     * @return self
     */
    public function setDetails($details)
    {
        $this->container['details'] = $details;

        return $this;
    }

    /**
     * Gets expiration_date
     *
     * @return string|null
     */
    public function getExpirationDate()
    {
        return $this->container['expiration_date'];
    }

    /**
     * Sets expiration_date
     *
     * @param string|null $expiration_date The expiration date for this payment method. This is mostly used by cards where the card might have an expiration date.
     *
     * @return self
     */
    public function setExpirationDate($expiration_date)
    {
        if (!is_null($expiration_date) && (mb_strlen($expiration_date) > 5)) {
            throw new \InvalidArgumentException('invalid length for $expiration_date when calling TransactionPaymentMethod., must be smaller than or equal to 5.');
        }
        if (!is_null($expiration_date) && (mb_strlen($expiration_date) < 5)) {
            throw new \InvalidArgumentException('invalid length for $expiration_date when calling TransactionPaymentMethod., must be bigger than or equal to 5.');
        }
        if (!is_null($expiration_date) && (!preg_match("/^\\d{2}\/\\d{2}$/", $expiration_date))) {
            throw new \InvalidArgumentException("invalid value for $expiration_date when calling TransactionPaymentMethod., must conform to the pattern /^\\d{2}\/\\d{2}$/.");
        }

        $this->container['expiration_date'] = $expiration_date;

        return $this;
    }

    /**
     * Gets external_identifier
     *
     * @return string|null
     */
    public function getExternalIdentifier()
    {
        return $this->container['external_identifier'];
    }

    /**
     * Sets external_identifier
     *
     * @param string|null $external_identifier An external identifier that can be used to match the payment method against your own records.
     *
     * @return self
     */
    public function setExternalIdentifier($external_identifier)
    {
        $this->container['external_identifier'] = $external_identifier;

        return $this;
    }

    /**
     * Gets label
     *
     * @return string|null
     */
    public function getLabel()
    {
        return $this->container['label'];
    }

    /**
     * Sets label
     *
     * @param string|null $label A label for the payment method. This can be the last 4 digits for a card, or the email address for an alternative payment method.
     *
     * @return self
     */
    public function setLabel($label)
    {
        $this->container['label'] = $label;

        return $this;
    }

    /**
     * Gets last_replaced_at
     *
     * @return \DateTime|null
     */
    public function getLastReplacedAt()
    {
        return $this->container['last_replaced_at'];
    }

    /**
     * Sets last_replaced_at
     *
     * @param \DateTime|null $last_replaced_at The date and time when this card was last replaced.  When the Account Updater determines that new card details are available, existing details are not changed immediately. There are three scenarios in which the actual replacement occurs:  1. When this card has expired. 2. When only the expiration date changed. 3. When a transaction using this card is declined with any of the following codes:     * `canceled_payment_method`     * `expired_payment_method`     * `unavailable_payment_method`     * `unknown_payment_method`  When the replacement is applied, this field is updated. For non-card payment methods, the value of this field is always set to `null`.
     *
     * @return self
     */
    public function setLastReplacedAt($last_replaced_at)
    {
        $this->container['last_replaced_at'] = $last_replaced_at;

        return $this;
    }

    /**
     * Gets method
     *
     * @return string|null
     */
    public function getMethod()
    {
        return $this->container['method'];
    }

    /**
     * Sets method
     *
     * @param string|null $method The type of this payment method.
     *
     * @return self
     */
    public function setMethod($method)
    {
        $allowedValues = $this->getMethodAllowableValues();
        if (!is_null($method) && !in_array($method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'method', must be one of '%s'",
                    $method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['method'] = $method;

        return $this;
    }

    /**
     * Gets payment_account_reference
     *
     * @return string|null
     */
    public function getPaymentAccountReference()
    {
        return $this->container['payment_account_reference'];
    }

    /**
     * Sets payment_account_reference
     *
     * @param string|null $payment_account_reference The payment account reference (PAR) returned by the card scheme. This is a unique reference to the underlying account that has been used to fund this payment method. This value will be unique if the same underlying account was used, regardless of the actual payment method used. For example, a network token or an Apple Pay device token will return the same PAR when possible.  The uniqueness of this value will depend on the card scheme, please refer to their documentation for further details. The availability of the PAR in our API depends on the availability of its value in the API of the payment service used for the transaction.
     *
     * @return self
     */
    public function setPaymentAccountReference($payment_account_reference)
    {
        $this->container['payment_account_reference'] = $payment_account_reference;

        return $this;
    }

    /**
     * Gets scheme
     *
     * @return string|null
     */
    public function getScheme()
    {
        return $this->container['scheme'];
    }

    /**
     * Sets scheme
     *
     * @param string|null $scheme An additional label used to differentiate different sub-types of a payment method. Most notably this can include the type of card used in a transaction. This field is `null` for the non-card payment methods. This represents the card scheme sent to the connector and it could be different from the actual card scheme that is being used by the PSP to process the transaction in the following situations: 1. `use_additional_scheme` transformation is used with the `PAN` instrument but we already have a PSP token for the card. 2. `use_additional_scheme` transformation is used but PSP has fallen back to the main card scheme internally.
     *
     * @return self
     */
    public function setScheme($scheme)
    {
        $allowedValues = $this->getSchemeAllowableValues();
        if (!is_null($scheme) && !in_array($scheme, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'scheme', must be one of '%s'",
                    $scheme,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scheme'] = $scheme;

        return $this;
    }

    /**
     * Gets fingerprint
     *
     * @return string|null
     */
    public function getFingerprint()
    {
        return $this->container['fingerprint'];
    }

    /**
     * Sets fingerprint
     *
     * @param string|null $fingerprint The unique hash derived from the payment method identifier (e.g. card number).
     *
     * @return self
     */
    public function setFingerprint($fingerprint)
    {
        $this->container['fingerprint'] = $fingerprint;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


